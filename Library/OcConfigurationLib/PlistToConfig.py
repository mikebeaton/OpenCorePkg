#!/usr/bin/env python3

#  Copyright (c) 2020, Mike Beaton. All rights reserved.
#  SPDX-License-Identifier: BSD-3-Clause

"""
Generate OpenCore .c and .h plist config definition files from template plist file.
"""

import base64
import io
import os
import sys
import xml.etree.ElementTree as ET

from dataclasses import dataclass

# Available flags for -f:

# show markup with implied types added
SHOW_PLIST = 1 << 0
# show creation of plist schema objects
SHOW_PLIST_SCHEMA = 1 << 1
# show creation of OC schema objects
SHOW_OC_SCHEMA = 1 << 2
# show processing steps
SHOW_DEBUG = 1 << 3
# show additional context used in processing
SHOW_CONTEXT = 1 << 4

flags = 0

# output string buffers
h_types = None
c_structors = None
c_schema = None

# support customisation for other apps
DEFAULT_PREFIX = 'Oc'

camel_prefix = None
upper_prefix = None

SHARED_HEADER = \
'''/** @file
  Copyright (C) 2019-2020, vit9696. All rights reserved.

  All rights reserved.

  This program and the accompanying materials
  are licensed and made available under the terms and conditions of the BSD License
  which accompanies this distribution.  The full text of the license may be found at
  http://opensource.org/licenses/bsd-license.php

  THE PROGRAM IS DISTRIBUTED UNDER THE BSD LICENSE ON AN "AS IS" BASIS,
  WITHOUT WARRANTIES OR REPRESENTATIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED.
**/

///
/// This file generated by PlistToConfig.py, do not edit
///
'''

C_TEMPLATE = \
'''
#include <Library/OcConfigurationLib.h>

[[BODY]]
EFI_STATUS
[[Prefix]]ConfigurationInit (
  OUT [[PREFIX]]_GLOBAL_CONFIG   *Config,
  IN  VOID               *Buffer,
  IN  UINT32             Size
  )
{
  BOOLEAN  Success;

  [[PREFIX]]_GLOBAL_CONFIG_CONSTRUCT (Config, sizeof (*Config));
  Success = ParseSerialized (Config, &mRootConfigurationInfo, Buffer, Size);

  if (!Success) {
    [[PREFIX]]_GLOBAL_CONFIG_DESTRUCT (Config, sizeof (*Config));
    return EFI_UNSUPPORTED;
  }

  return EFI_SUCCESS;
}

VOID
[[Prefix]]ConfigurationFree (
  IN OUT [[PREFIX]]_GLOBAL_CONFIG   *Config
  )
{
  [[PREFIX]]_GLOBAL_CONFIG_DESTRUCT (Config, sizeof (*Config));
}
'''

H_TEMPLATE = \
'''
#ifndef [[PREFIX]]_CONFIGURATION_LIB_H
#define [[PREFIX]]_CONFIGURATION_LIB_H

#include <Library/DebugLib.h>
#include <Library/OcSerializeLib.h>
#include <Library/OcBootManagementLib.h>
#include <Library/OcConfigurationConstants.h>

[[BODY]]/**
  Initialize configuration with plist data.

  @param[out]  Config   Configuration structure.
  @param[in]   Buffer   Configuration buffer in plist format.
  @param[in]   Size     Configuration buffer size.

  @retval  EFI_SUCCESS on success
**/
EFI_STATUS
[[Prefix]]ConfigurationInit (
  OUT [[PREFIX]]_GLOBAL_CONFIG   *Config,
  IN  VOID               *Buffer,
  IN  UINT32             Size
  );

/**
  Free configuration structure.

  @param[in,out]  Config   Configuration structure.
**/
VOID
[[Prefix]]ConfigurationFree (
  IN OUT [[PREFIX]]_GLOBAL_CONFIG   *Config
  );

#endif // [[PREFIX]]_CONFIGURATION_LIB_H
'''

##
# Errors and IO
#

column_pos = {}

def tab_print(*args, **kwargs):
  kwargs['end'] = ''
  kwargs['sep'] = ''
  file = kwargs.get('file', sys.stdout)

  pos = column_pos.get(file, 0)

  s = io.StringIO()

  kwargs['file'] = s

  print(*args, **kwargs)
  count = s.tell()
  column_pos[file] = pos + count
  s.seek(0)

  kwargs['file'] = file
  print(s.read(), **kwargs)

  s.close()

def tab_to(col, file):
  pos = column_pos.get(file, 0)
  count = col - pos
  if count > 0:
    column_pos[file] = col
    for _ in range(count):
      print(' ', file=file, end='')

def tab_nl(file):
  column_pos[file] = 0
  print(file=file)

def error(*args, **kwargs):
  print('ERROR: ', *args, sep='', file=sys.stderr, **kwargs)
  sys.exit(-1)

def internal_error(*args, **kwargs):
  print('INTERNAL_ERROR: ', *args, sep='', file=sys.stderr, **kwargs)
  sys.exit(-1)

def debug(*args, **kwargs):
  if flags & SHOW_DEBUG != 0:
    print('DEBUG: ', *args, sep='', **kwargs)

def info_print(*args, **kwargs):
  if kwargs.pop('info_flags', 0) & flags != 0:
    for _ in range(0, kwargs.pop('tab', 0)):
      print(end='\t')
    print(*args, sep='', **kwargs)

def plist_print(*args, **kwargs):
  info_print(*args, info_flags=SHOW_PLIST, **kwargs)

def plist_schema_print(*args, **kwargs):
  info_print(*args, info_flags=SHOW_PLIST_SCHEMA, **kwargs)

def oc_schema_print(*args, **kwargs):
  info_print(*args, info_flags=SHOW_OC_SCHEMA, **kwargs)

def attr_print(name, value, flags):
  if value is not None:
    info_print(' ', name, '=', info_flags=flags, end='')
    if type(value) is list:
      info_print(value, info_flags=flags, end='')
    else:
      info_print('"', value, '"', info_flags=flags, end='')

def plist_schema_attr_print(name, value):
  attr_print(name, value, SHOW_PLIST_SCHEMA)

def oc_schema_attr_print(name, value):
  attr_print(name, value, SHOW_OC_SCHEMA)

def context_print(*args, **kwargs):
  info_print(*args, info_flags=SHOW_CONTEXT, **kwargs)

##
# Emit file elements
#

def emit_section_name(key):
  print('/**', file = h_types)
  comment = key.comment
  if comment is None:
    comment = key.value
  print('  %s section' % comment, file = h_types)
  print('**/', file = h_types)
  print(file = h_types)

def upper_path(path):
  return '_'.join(p.upper() for p in path)

def set_def_name(elem, elem_type):
  use_path = elem.path.copy()
  if len(elem.path) == 0:
    use_path.append('GLOBAL')
  if len(elem.path) <= 1:
    use_path.append('CONFIG')
  elif elem_type is not None:
    use_path.append(elem_type)
  upath = upper_path(use_path)
  elem.def_name = '%s_%s' % (upper_prefix, upath)

def emit_root_config():
  print('/**', file = h_types)
  print('  Root configuration', file = h_types)
  print('**/', file = h_types)
  print(file = h_types)

def emit_comment(elem):
  if elem.comment is not None:
    print('///', file = h_types)
    print('/// %s.' % elem.comment, file = h_types)
    print('///', file = h_types)

def emit_struct(elem, context):
  context_print('STRUCT CONTEXT: ', context)
  if context == 'array':
    set_def_name(elem, 'ENTRY')
  elif context == 'struct':
    set_def_name(elem, None)
  else:
    set_def_name(elem, 'ARRAY')

  if len(elem.path) == 0:
    emit_root_config()

  emit_comment(elem)

  print('#define %s_FIELDS(_, __) \\' % elem.def_name, file = h_types)

  last = len(elem.of) - 1
  for (i, of) in enumerate(elem.of):
    tab_to(2, file = h_types)
    tab_print('_(', file = h_types)
    tab_print(of.def_name, file = h_types)

    tab_to(36, file = h_types)
    tab_print(', ', of.name, file = h_types)

    tab_to(57, file = h_types)
    tab_print(', ', file = h_types)
    if of.size is not None:
      tab_print('[', of.size, ']', file = h_types)

    tab_to(63, file = h_types)
    tab_print(', , )', file = h_types)

    if i < last:
      tab_print(' \\', file = h_types)

    tab_nl(file = h_types)

  print('  OC_DECLARE (%s)' % elem.def_name, file = h_types)
  print(file = h_types)

def emit_array(elem, context):
  context_print('ARRAY CONTEXT:', context)
  if context == 'map':
    set_def_name(elem, 'ENTRY')
  else:
    set_def_name(elem, 'ARRAY')

  emit_comment(elem)

  print('#define %s_FIELDS(_, __) \\' % elem.def_name, file = h_types)
  print('  OC_ARRAY (%s, _, __)' % elem.of.def_name, file = h_types)
  print('  OC_DECLARE (%s)' % elem.def_name , file = h_types)
  print(file = h_types)

def emit_map(elem):
  set_def_name(elem, 'MAP')

  emit_comment(elem)

  print('#define %s_FIELDS(_, __) \\' % elem.def_name, file = h_types)
  print('  OC_MAP (OC_STRING, %s, _, __)' % elem.of.def_name, file = h_types)
  print('  OC_DECLARE (%s)' % elem.def_name , file = h_types)
  print(file = h_types)

##
# Schema objects
#

@dataclass
class PlistKey:
  schema_type: str
  comment: str
  value: str
  path_spec: str
  replace_name: str

  def __init__(
    self,
    comment: str = None,
    value: str = None,
    path_spec: str = None,
    replace_name: str = None,
    tab: int = 0
    ):

    self.schema_type = 'key'
    self.comment = comment
    self.value = value
    self.path_spec = path_spec
    self.replace_name = replace_name

    plist_schema_print('[plist:key', tab=tab, end='')
    plist_schema_attr_print('comment', comment)
    plist_schema_attr_print('value', value)
    plist_schema_attr_print('path', path_spec)
    plist_schema_attr_print('name', replace_name)
    plist_schema_print(']')

    if path_spec is None:
      self.path_spec = value

@dataclass
class OcSchemaElement:
  schema_type: str
  name: str
  path: str
  data_type: str
  size: str
  comment: str
  value: str
  of: object
  # .h file definition name, once emitted
  def_name: str

  def __init__(
    self,
    schema_type: str,
    name: str = None,
    path: str = None,
    size: str = None,
    comment: str = None,
    value: str = None,
    of: object = None,
    def_name: str = None,
    tab: int = 0
    ):

    self.schema_type = schema_type
    self.name = name
    self.path = path
    self.size = size
    self.comment = comment
    self.value = value
    self.of = of
    self.def_name = def_name

    oc_schema_print('[OC:', schema_type, tab=tab, end='')
    oc_schema_attr_print('name', name)
    oc_schema_attr_print('path', path)
    oc_schema_attr_print('size', size)
    oc_schema_attr_print('comment', comment)
    oc_schema_attr_print('value', value)
    of_type = None
    if of is not None:
      if type(of) is list:
        of_type = 'list[%d]' % len(of)
      else:
        of_type = of.schema_type
    oc_schema_attr_print('of', of_type)
    oc_schema_attr_print('def_name', def_name)
    oc_schema_print(']')

  def set_name(
    self,
    name,
    tab = 0
    ):

    if self.name is not None:
      internal_error('name should not get set more than once on OcSchemaElement')
    self.name = name
    oc_schema_print('... [name="', name, '"]', tab=tab)

##
# Parsing
#

def plist_start(elem, tab):
  plist_print('<', elem.tag, end='', tab=tab)

def plist_stop():
  plist_print('>')

def plist_attr(name, value):
  if value is not None:
    plist_print(' ', name, '="', value, '"', end='')

def plist_end_and_close(elem, contents):
  if contents is not None:
    plist_print('>', contents, '</', elem.tag, '>')
  else:
    plist_print('/>')

def plist_open(elem, tab):
  plist_print('<', elem.tag, '>', tab=tab)

def plist_close(elem, tab):
  plist_print('</', elem.tag, '>', tab=tab)

def plist_open_close(elem, tab):
  plist_start(elem, tab)
  plist_end_and_close(elem, elem.text)

def consume_attr(elem, name):
  value = elem.attrib.get(name, None)
  plist_attr(name, value)
  return value

def check_key(parent, child, index):
  if child.schema_type != 'key':
    error('<key> required as ', 'first' if index == 0 else 'every even' , ' element of <', parent.tag, '>')

def parse_key(elem, tab):
  plist_start(elem, tab)
  replace_name = consume_attr(elem, 'name')
  path_spec = consume_attr(elem, 'path')
  comment = consume_attr(elem, 'comment')
  plist_end_and_close(elem, elem.text)

  return PlistKey(value=elem.text, replace_name=replace_name, path_spec=path_spec, comment=comment, tab=tab)

def parse_data(elem, tab, path):
  schema_type = elem.attrib.get('type', None)
  size = elem.attrib.get('size', None)
  data = elem.text

  if data is not None:
    data_bytes = base64.b64decode(data)
    data_print = '0x' + data_bytes.hex()
  else:
    data_bytes = None
    data_print = None

  if data is not None and (schema_type is None or size is None):
    length = len(data_bytes)

    if schema_type is None:
      if length == 2:
        schema_type = 'uint16'
      elif length == 4:
        schema_type = 'uint32'
      elif length == 8:
        schema_type = 'uint64'
      else:
        schema_type = 'uint8'

    if schema_type == 'uint8' and length != 1 and size is None:
      size = str(length)

  if schema_type is None:
    if size is None:
      schema_type = 'blob'
    else:
      schema_type = 'uint8'
  elif schema_type == 'blob' and size is not None:
    error('size attribute not valid with schema_type="blob"')

  plist_start(elem, tab)
  plist_attr('type', schema_type)
  plist_attr('size', size)
  plist_end_and_close(elem, data_print)

  schema_type = schema_type.upper()
  if schema_type == 'BLOB':
    schema_type = 'OC_DATA'

  return OcSchemaElement(schema_type=schema_type, size=size, value=data_print, tab=tab, path=path, def_name=schema_type)

def skipping(count, tab, used_count = 0):
  skip = count - used_count
  if skip > 0:
    plist_print('(skipping ', skip, ' item', '' if skip == 1 else 's' , ')', tab=(tab + 1))

def parse_array(elem, tab, path, key, context):
  plist_start(elem, tab)
  comment = consume_attr(elem, 'comment')
  xref = consume_attr(elem, 'xref')
  plist_stop()

  count = len(elem)

  if xref is not None:
    skipping(count, tab)
    elem_array = OcSchemaElement(schema_type='OC_ARRAY', tab=tab, path=path, comment=comment, def_name=xref)
  else:
    if count == 0:
      error('No template for <array>')

    child = parse_elem(elem[0], tab, path, None, context='array')

    skipping(count, tab, used_count=1)

    elem_array = OcSchemaElement(schema_type='OC_ARRAY', of=child, tab=tab, path=path, comment=comment)
    emit_array(elem_array, context)

  plist_close(elem, tab)

  return elem_array

def init_dict(elem, path, tab, map):
  plist_start(elem, tab=tab)
  plist_attr('type', 'map' if map else None)
  comment = consume_attr(elem, 'comment')
  xref = consume_attr(elem, 'xref')
  new_path = consume_attr(elem, 'path')
  plist_stop()

  count = len(elem)

  if count == 0 and xref is not None:
    error('No elements in <dict>')

  if count % 2 != 0:
    error('Number of nodes in <dict> must be even')

  # used where name of child needs to differ from name of parent
  if new_path is not None:
    replace_path = path.copy()
    del replace_path[-1]
    replace_path.append(new_path)
  else:
    replace_path = path

  return (count >> 1, comment, xref, replace_path)

def parse_map(elem, tab, path, key):
  (count, comment, xref, replace_path) = init_dict(elem, path, tab, True)

  if xref is not None:
    # no particular reason not to add it following the pattern of struct and array, just not (yet?) required
    error('no support for xref in map')

  key = parse_elem(elem[0], tab, path, None)

  check_key(elem, key, 0)

  oc_value = parse_elem(elem[1], tab, path, None, context='map')

  count -= 1

  skipping(count, tab)

  plist_close(elem, tab)

  if oc_value.schema_type == 'OC_DATA':
    return OcSchemaElement(schema_type='OC_ASSOC', tab=tab, path=replace_path, def_name = 'OC_ASSOC')
  else:
    elem_map = OcSchemaElement(schema_type='OC_MAP', of=oc_value, tab=tab, path=replace_path, comment=comment)
    emit_map(elem_map)
    return elem_map

def parse_struct(elem, tab, path, key, context):
  (count, comment, xref, replace_path) = init_dict(elem, path, tab, False)

  if xref is not None:
    skipping(count, tab)
    elem_struct = OcSchemaElement(schema_type='OC_STRUCT', tab=tab, path=replace_path, comment=comment, def_name=xref)
  else:
    fields = []

    index = 0
    while count > 0:
      key = parse_elem(elem[index], tab, path, None)

      check_key(elem, key, index)

      if key.value is None and key.replace_name is None:
        error('<key> tag within <dict> fields template must have name attribute or xml content to use as variable name')

      if len(path) == 0:
        emit_section_name(key)

      oc_child = parse_elem(elem[index + 1], tab, path, key.path_spec, context = 'struct')

      oc_child.set_name(key.replace_name if key.replace_name is not None else key.value, tab=tab)

      fields.append(oc_child)

      count -= 1
      index += 2

    elem_struct = OcSchemaElement(schema_type='OC_STRUCT', of=fields, tab=tab, path=replace_path, comment=comment)
    emit_struct(elem_struct, context)

  plist_close(elem, tab)

  return elem_struct

def parse_plist(elem, tab, path, key):
  plist_open(elem, tab)

  count = len(elem)
  if count != 1:
    error('Invalid contents for <plist>')

  child = parse_elem(elem[0], tab, path, None, indent=False)

  plist_close(elem, tab)

  return child

def parse_elem(elem, tab, path, key, indent = True, context = None):
  if tab == None:
    tab = 0

  if indent:
    tab += 1

  context_print('CONTEXT: ', context, tab = tab)
  
  if path is None:
    replace_path = None
  else:
    replace_path = path.copy()
    if key is not None:
      replace_path.append(key) # NB modifies list, returns None

  if elem.tag == 'key':
    return parse_key(elem, tab)

  if elem.tag == 'true' or elem.tag == 'false':
    plist_open_close(elem, tab)
    return OcSchemaElement(schema_type='BOOLEAN', value=elem.tag, tab=tab, path=replace_path, def_name='BOOLEAN')

  if elem.tag == 'string':
    plist_open_close(elem, tab)
    return OcSchemaElement(schema_type='OC_STRING', value=elem.text, tab=tab, path=replace_path, def_name='OC_STRING')

  if elem.tag == 'integer':
    plist_open_close(elem, tab)
    return OcSchemaElement(schema_type='UINT32', value=elem.text, tab=tab, path=replace_path, def_name='UINT32')

  if elem.tag == 'data':
    return parse_data(elem, tab, replace_path)

  if elem.tag == 'array':
    return parse_array(elem, tab, replace_path, None, context)

  if elem.tag == 'dict':
    if elem.attrib.get('type', None) == 'map':
      return parse_map(elem, tab, replace_path, key)
    else:
      return parse_struct(elem, tab, replace_path, key, context)

  if elem.tag == 'plist':
    return parse_plist(elem, tab, replace_path, key)

  error('Unhandled tag:', elem.tag)

devnull = open(os.devnull, 'w')

def file_close(handle):
  if handle != devnull and handle != sys.stdout:
    debug('Closing: ', handle)
    handle.close()

def error_on_twice(flag, handle):
  if handle is not None:
    error(flag, ' specified twice')

def customise_template(template, body):
  return template \
    .replace('[[Prefix]]', camel_prefix) \
    .replace('[[PREFIX]]', upper_prefix) \
    .replace('[[BODY]]', body)

##
# Usage, input args, general init
#

# usage
argc = len(sys.argv)
if argc < 2:
  print('PlistToConfig [-c c-file] [-h h-file] [-f print-flags] [-p prefix] plist-file')
  sys.exit(-1)

# file handles
c_file = None
h_file = None

# string buffers
h_types = io.StringIO()
c_structors = io.StringIO()
c_schema = io.StringIO()

## DEBUG
##print('// h_types', file=h_types)
print('// c_structors', file=c_structors)
print('// c_schema', file=c_schema)

# main template filename
plist_filename = None

# parse args
skip = False
for i in range(1, argc):

  if skip:
    
    skip = False
    continue

  arg = sys.argv[i]
  skip = True

  if arg == '-f' or arg == '-p':

    if i + 1 >= argc:
      error('Missing value for ', arg, ' flag')

    if arg == '-f':

      flags = int(sys.argv[i + 1])
      debug('flags = ', flags)

    elif arg == '-p':

      camel_prefix = sys.argv[i + 1]
      debug('prefix = \'', camel_prefix, '\'')

    else:

      internal_error('flag error')

  elif arg == '-c' or arg == '-h':

    if i + 1 >= argc:
      error('Missing file for ', arg)

    flag_filename = sys.argv[i + 1]

    if flag_filename == '-':
      handle = sys.stdout
    elif flag_filename.startswith('-'):
      error('Missing file for ', arg)
    else:
      handle = open(flag_filename, 'w')

    debug(arg, ' ', handle)

    if arg == '-c':
      error_on_twice(arg, c_file)
      c_file = handle
    elif arg == '-h':
      error_on_twice(arg, h_file)
      h_file = handle
    else:
      internal_error('file flag error')

  elif not arg.startswith('-'):

    if plist_filename is not None:
      error('\'', arg, '\': too many input files, already using \'', plist_filename, '\'')

    plist_filename = arg
    debug('input: \'', plist_filename, '\'')
    skip = False

  else:

    error('Unknown flag ', arg)

if plist_filename is None:
  error('No input file')

if camel_prefix is None:
  camel_prefix = DEFAULT_PREFIX
upper_prefix = camel_prefix.upper()

if c_file is None:
  c_file = devnull

if h_file is None:
  h_file = devnull

# ElementTree read plist file into memory
debug('Reading plist XML from \'', plist_filename, '\'')
root = ET.parse(plist_filename).getroot()

# process into string buffers
debug('Parsing plist in memory')
parse_elem(root, None, [], None, indent=False)

# write output
c_structors.seek(0)
c_schema.seek(0)
h_types.seek(0)

debug('Writing c file')
print(SHARED_HEADER, file=c_file, end='')
print(customise_template(C_TEMPLATE, c_structors.read() + c_schema.read()), file=c_file, end='')

file_close(c_file)

debug('Writing h file')
print(SHARED_HEADER, file=h_file, end='')
print(customise_template(H_TEMPLATE, h_types.read()), file=h_file, end='')

file_close(h_file)

debug('Done')
sys.exit(0)
